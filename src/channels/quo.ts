/**
 * Quo Phone (OpenPhone) SMS Channel
 * Receives inbound SMS via webhook + polling fallback, sends outbound via OpenPhone API.
 * JID format: quo:+1XXXXXXXXXX (the business phone number)
 */
import http from 'http';

import {
  ASSISTANT_NAME,
  QUO_API_KEY,
  QUO_SNAK_NUMBER,
  QUO_SNAK_PHONE_ID,
  QUO_SHERIDAN_NUMBER,
  QUO_SHERIDAN_PHONE_ID,
  QUO_WEBHOOK_PORT,
} from '../config.js';
import { upsertContactFromPhone } from '../db.js';
import { logger } from '../logger.js';
import { Channel, NewMessage, OnChatMetadata, OnInboundMessage, RegisteredGroup } from '../types.js';

const QUO_API_BASE = 'https://api.openphone.com/v1';
const POLL_INTERVAL_MS = 15_000; // Poll every 15 seconds

export interface QuoChannelOpts {
  onMessage: OnInboundMessage;
  onChatMetadata: OnChatMetadata;
  registeredGroups: () => Record<string, RegisteredGroup>;
}

/** Map business number → OpenPhone phoneNumberId for outbound sending. */
interface PhoneLine {
  phoneId: string;
  number: string;
}

export class QuoChannel implements Channel {
  name = 'quo';

  private server: http.Server | null = null;
  private connected = false;
  private opts: QuoChannelOpts;
  private pollTimer: ReturnType<typeof setInterval> | null = null;

  /**
   * Track last inbound sender per JID so we know who to reply to.
   * Key: quo:+1XXXX (business line JID), Value: customer phone number (+1YYYY)
   */
  private lastSenderByJid = new Map<string, string>();

  /** Track last seen activity ID per conversation to detect new messages. */
  private lastActivityByConversation = new Map<string, string>();

  /** Track message IDs we've already processed (dedup between webhook and polling). */
  private processedMessageIds = new Set<string>();

  /** Map business number → phoneId for outbound routing. */
  private phoneLines: PhoneLine[] = [];

  constructor(opts: QuoChannelOpts) {
    this.opts = opts;

    // Register configured phone lines
    if (QUO_SNAK_PHONE_ID && QUO_SNAK_NUMBER) {
      this.phoneLines.push({ phoneId: QUO_SNAK_PHONE_ID, number: QUO_SNAK_NUMBER });
    }
    if (QUO_SHERIDAN_PHONE_ID && QUO_SHERIDAN_NUMBER) {
      this.phoneLines.push({ phoneId: QUO_SHERIDAN_PHONE_ID, number: QUO_SHERIDAN_NUMBER });
    }
  }

  async connect(): Promise<void> {
    // Start webhook server
    await new Promise<void>((resolve) => {
      this.server = http.createServer((req, res) => {
        if (req.method === 'POST' && req.url === '/webhook/quo') {
          this.handleWebhook(req, res);
        } else {
          res.writeHead(200);
          res.end('ok');
        }
      });

      this.server.listen(QUO_WEBHOOK_PORT, () => {
        this.connected = true;
        logger.info({ port: QUO_WEBHOOK_PORT }, 'Quo webhook server listening');
        resolve();
      });
    });

    // Start polling fallback (webhooks are unreliable)
    this.startPolling();
  }

  async sendMessage(jid: string, text: string): Promise<void> {
    // Find the phone line for this JID
    const businessNumber = jid.replace('quo:', '');
    const line = this.phoneLines.find((l) => l.number === businessNumber);
    if (!line) {
      logger.warn({ jid }, 'No Quo phone line configured for JID');
      return;
    }

    // Find the customer number to reply to
    const customerNumber = this.lastSenderByJid.get(jid);
    if (!customerNumber) {
      logger.warn({ jid }, 'No customer number known for Quo reply');
      return;
    }

    // Prefix with assistant name for consistency
    const prefixed = `${ASSISTANT_NAME}: ${text}`;

    try {
      const response = await fetch(`${QUO_API_BASE}/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': QUO_API_KEY,
        },
        body: JSON.stringify({
          content: prefixed,
          from: line.phoneId,
          to: [customerNumber],
        }),
      });

      if (!response.ok) {
        const body = await response.text();
        logger.error({ jid, status: response.status, body }, 'Quo send failed');
      } else {
        logger.info({ jid, to: customerNumber, length: prefixed.length }, 'Quo message sent');
      }
    } catch (err) {
      logger.error({ jid, err }, 'Quo send error');
    }
  }

  isConnected(): boolean {
    return this.connected;
  }

  ownsJid(jid: string): boolean {
    return jid.startsWith('quo:');
  }

  async disconnect(): Promise<void> {
    this.connected = false;
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
    if (this.server) {
      await new Promise<void>((resolve) => this.server!.close(() => resolve()));
    }
  }

  // SMS does not support typing indicators
  // setTyping is intentionally not implemented

  // ── Webhook handler ──────────────────────────────────────────────

  private handleWebhook(req: http.IncomingMessage, res: http.ServerResponse): void {
    let body = '';
    req.on('data', (chunk) => { body += chunk; });
    req.on('end', () => {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end('{"ok":true}');

      try {
        const payload = JSON.parse(body);
        this.processWebhookPayload(payload);
      } catch (err) {
        logger.error({ err }, 'Failed to parse Quo webhook payload');
      }
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processWebhookPayload(payload: any): void {
    if (payload.type !== 'message.received') return;

    const msg = payload.data?.object;
    if (!msg || msg.direction !== 'incoming') return;

    this.processMessage(msg, 'webhook');
  }

  // ── Polling ──────────────────────────────────────────────────────

  private startPolling(): void {
    logger.info({ intervalMs: POLL_INTERVAL_MS, lines: this.phoneLines.length }, 'Quo polling started');

    // Initial poll after a short delay
    setTimeout(() => this.pollAllLines(), 3000);

    this.pollTimer = setInterval(() => this.pollAllLines(), POLL_INTERVAL_MS);
  }

  private async pollAllLines(): Promise<void> {
    for (const line of this.phoneLines) {
      try {
        await this.pollLine(line);
      } catch (err) {
        logger.warn({ err, phone: line.number }, 'Quo poll error');
      }
    }
  }

  private async pollLine(line: PhoneLine): Promise<void> {
    // Fetch recent conversations for this phone line
    const url = new URL(`${QUO_API_BASE}/conversations`);
    url.searchParams.set('phoneNumberId', line.phoneId);
    url.searchParams.set('maxResults', '10');

    const convRes = await fetch(url.toString(), {
      headers: { 'Authorization': QUO_API_KEY },
    });

    if (!convRes.ok) return;

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const convData = await convRes.json() as { data?: any[] };
    if (!convData.data) return;

    // Filter to conversations belonging to this phone line
    const lineConvs = convData.data.filter(
      (c: { phoneNumberId?: string }) => c.phoneNumberId === line.phoneId
    );

    for (const conv of lineConvs) {
      const lastActivityId = conv.lastActivityId;
      const prevActivityId = this.lastActivityByConversation.get(conv.id);

      // On first run, just record the current state without fetching messages
      if (!prevActivityId) {
        this.lastActivityByConversation.set(conv.id, lastActivityId);
        continue;
      }

      // If activity hasn't changed, skip
      if (lastActivityId === prevActivityId) continue;

      // New activity detected — fetch recent messages
      logger.info({ convId: conv.id, phone: line.number, participants: conv.participants }, 'Quo poll: new activity detected');
      this.lastActivityByConversation.set(conv.id, lastActivityId);

      const participants: string[] = conv.participants || [];
      if (participants.length === 0) continue;

      await this.fetchNewMessages(line, participants);
    }
  }

  private async fetchNewMessages(line: PhoneLine, participants: string[]): Promise<void> {
    const url = new URL(`${QUO_API_BASE}/messages`);
    url.searchParams.set('phoneNumberId', line.phoneId);
    participants.forEach((p: string, i: number) => {
      url.searchParams.set(`participants[${i}]`, p);
    });
    url.searchParams.set('maxResults', '5');

    const msgRes = await fetch(url.toString(), {
      headers: { 'Authorization': QUO_API_KEY },
    });

    if (!msgRes.ok) return;

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const msgData = await msgRes.json() as { data?: any[] };
    if (!msgData.data) return;

    // Process messages in chronological order (API returns newest first)
    for (const msg of msgData.data.reverse()) {
      if (msg.direction !== 'incoming') continue;
      this.processMessage(msg, 'poll');
    }
  }

  // ── Shared message processing ────────────────────────────────────

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processMessage(msg: any, source: 'webhook' | 'poll'): void {
    const msgId = msg.id;
    if (!msgId) return;

    // Dedup: skip messages we've already processed (from webhook or previous poll)
    if (this.processedMessageIds.has(msgId)) return;
    this.processedMessageIds.add(msgId);

    // Cap dedup set size to prevent memory leak
    if (this.processedMessageIds.size > 5000) {
      const entries = [...this.processedMessageIds];
      this.processedMessageIds = new Set(entries.slice(-2500));
    }

    const customerNumber = msg.from;
    const businessNumber = Array.isArray(msg.to) ? msg.to[0] : msg.to;
    const text = msg.text || msg.body || '';

    if (!customerNumber || !businessNumber || !text) return;

    // Determine which business line received this
    const line = this.phoneLines.find((l) => l.phoneId === msg.phoneNumberId);
    const jid = line ? `quo:${line.number}` : `quo:${businessNumber}`;

    logger.info({ source, from: customerNumber, jid, msgId }, 'Quo inbound SMS');

    // Track the customer number for reply routing
    this.lastSenderByJid.set(jid, customerNumber);

    const timestamp = msg.createdAt || new Date().toISOString();

    // Update chat metadata
    this.opts.onChatMetadata(jid, timestamp, `Quo ${line?.number || businessNumber}`);

    // Only deliver to registered groups
    const groups = this.opts.registeredGroups();
    if (!groups[jid]) return;

    const newMsg: NewMessage = {
      id: msgId,
      chat_jid: jid,
      sender: customerNumber,
      sender_name: customerNumber,
      content: text,
      timestamp,
      is_from_me: false,
      is_bot_message: false,
    };

    this.opts.onMessage(jid, newMsg);

    // Auto-create CRM contact from inbound SMS
    try {
      upsertContactFromPhone(customerNumber, `quo:${line?.number || businessNumber}`, []);
    } catch (err) {
      logger.debug({ err, phone: customerNumber }, 'CRM auto-create failed');
    }
  }
}
